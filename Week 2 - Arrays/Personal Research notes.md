asked: When programming in C, if I want to put all of my helper functions in their own C file (e.g. `myhelpers.c`) that will be linked to the main function file, do I also need a header file containing the forward declarations of the helpers? If so, why?

The short answer is it depends on the version of the C compiler you are using and how strict the implementors of the compiler are being in conforming to the ISO ‘C99’ definition (you should get an error or at least a warning), while traditional C compiler implementations may be silent — “just work.”

A longer answer is needed to explain the why; as the OP must understand C’s history and use. I’m an old guy and learned C a in the early 1970s — a number of years before Dennis and Brian would write the original ‘White Book’ (a.k.a. K&R v1) in 1978. When I first learned the language, what we would call later call the CPP or the C Preprocessor was a separate program from the compiler itself. Its syntax and operations were not formally part of the language. Modern programmers may not understand why C has some of these seemingly strange behaviors. So let’s unpack your question and examine it in the context of how C was developed, and it should be a bit more obvious.

C is a system programming language, like its direct predecessor B, contemporary BLISS, and some famous other systems languages from the 1960s like BCPL and what is most often considered the first, ESPOL. These languages were all developed to replace assembler language to remove much of the repetitive and error-prone duties that a system programmer has to handle with the assembler language for a particular ISA but still offer the efficiency and ‘optimal’ code that can be used with the core hardware components of the machine exposed and available to the programmer. So-called “high-level” programming languages such as FORTRAN, COBOL, and the ALGOL family offer the programmer an easy way to express ideas but “hid” many details of the hardware and thus (initially) would often produce binary code that was (at the time) not considered “production quality.” Furthermore, since these languages were often used on batch-oriented systems, they were often implemented as “load and go” style systems for one-time use of a program [See some of my other answers for why this was a fact and how that changed, which is beyond this answer's scope].

An important feature of the systems programming languages, including C when it was first defined, is that I/O is not part of the language - but an add-on provided by external libraries. What we today call the “programming language runtime library” that provides helper functions that the compiler could use when creating a binary was often unnecessary. Instead, a programmer would call the same I/O libraries for the local operating system developed for the assembler language. Whereas a language like, say, FORTRAN might have had a very well-defined set of support routines that needed to be “bound” with the user program after compilation but before it was able to be executed.

Thus when a C program was written in the early years of the language, it was bound with a program called the link editor (or linker for short), using the same library and in the same manner as an assembler program. Thus when a programmer called a routine that had not been defined, Dennis compiler “implicitly” defined the function as an external function — to be supplied by some other library.

Note that this idea of “separate compilation” of separate files (what we would later refer to as a “module”), and linking into a final result was native to the C programming language. Also, C was developed for us on an interactive system, where editing/development, compilation/linking and. execution were separate functions. This differs from the batch “load and go” compilers like the famous late 1960s the University of Waterloo’s WATFOR/WATFIV FORTRAN or Stanford Algol-W implementations developed for the mainframe when a deck of cards was loaded with a complete FORTRAN or Algol program. With these language systems, everything (including the data to run the resulting program) was either in the programmer’s deck or supplied by the compilation system.

As the C programming Language was moved to ISAs other than the original PDP-11 target, two changes/enhancements appeared early (in the mid-1970s - before K&R1 was published). Programmers desired to have a set of “common source” files for a program on different targets ISAs, say the Honeywell GCOS or IBM S/360-based systems. These additions were the introduction of the [C preprocessor](https://en.wikipedia.org/wiki/C_preprocessor "en.wikipedia.org") and a [portable I/O library](https://www.tuhs.org/cgi-bin/utree.pl?file=V6%2Fusr%2Fdoc%2Fiolib%2Fiolib "www.tuhs.org"). As I noted previously, these were not part of the language. The C pre-processor (`/lib/cpp`) was a separate program from the C compiler (`/lib/ccomp`). The portable I/O was written in C and assembler language for the target ISA and supplied at link time to be called by the C programmer instead of the local systems I/O library [BTW: this is different from some contemporaries systems languages like the BLISS programming language which always used the system libraries].

So the idea of having separately compiled files for your support routines (`myhelpers.c`) goes back to the original language and, in fact, is considered just good software engineering - since in an interactive world (unlike the batch-oriented “load and go” world of the IBM mainframe), it is just easier for the programmer.

However … early C suffered an issue that had begun to be exposed by high-level languages - the idea of data types. The ISAs offer programmers different operations depending on how the data in the functional units are to be interpreted. Languages like FORTRAN and Algol introduced the idea of Integers, Real Numbers, and Characters. They removed some of the burdens of the programmer by using the required actions that matched those data “types.” Earlier systems languages such as BCPL, B, and BLISS tended to be “type-less” (similar to the hardware) and offered the hardware concept of the “word” and then tried to infer from use what the programmer desired. The problem, of course, is if the programmer is not explicit and the compiler might infer the wrong thing, and a failure (or bug) will be introduced. In fact, C’s first real distinction from is predecessor B was to introduce a byte-oriented `char` data type, separating it from the integer/word-orient `int` data type. Once that was added, adding more data types, such as a pointer data type and pointer arithmetic, followed. However, Dennis allowed implicit operations tied to add a set of rules of when the compiler would perform specific actions that converted from the types, as system programmers often needed these sets of operations and were one of the things that allowed C to be as ‘efficient’ as assembler language in those times.

So you should see an immediate issue here. If a programmer were to use a variable, say `int gorp` in a file such as `main.c`, the program could define `gorp` in another file, say `globablstorage.c` as a different storage type, such as a `float` or a `char`. Since the variable was defined in the second file, the link editor would find the name when creating binary. However, the C compiler's actions in using `gorp` as an integer might not be correct (although it might have been when doing some funky systems programming) [remember - traditionally, link editors are binding names together, and other than possibly (not always) distinguishing between variables and functions/procedures - do not do “type checking”].

Similarly, a programmer can call a function, say `xyzzy`() in one file like `main.c`, that has an implementation in another file, `xyzzy.c`, or for that matter, later in the file `main.c`, and the definition of the function is unknown when it is first used.

C lived this way for many years and became immensely popular even with those issues. Programmers were forced to be disciplined and ensure that definitions and use/calls matched. Thus, using header files to define global variables and functions became the standard and accepted way to program C.

Since Dennis had started to introduce some level of typing into C to support the addressing scheme of the PDP-11 it was not a huge stretch to make that scheme stronger. But since checking of a data type was not strictly enforced, C was said to be a “weakly typed” language. The developers of a contemporary high-level language created and released around the same time (as a follow on to Algol-W) called Pascal used strong typing and professed to have the compiler catch these errors statically as a program was developed. Pascal’s developers believed strong-typing (i.e. explicit type definitions) to be better than using implicit type declaration and trying to have the compiler guess.

While Pascal became a popular programming language, it had other issues and eventually feel out of favor (see Brian Kerneghan’s outstanding paper: [Why Pascal is not my Favorite Programming Language](http://doc.cat-v.org/bell_labs/why_pascal/why_pascal_is_not_my_favorite_language.pdf "doc.cat-v.org")). But Pascal’s concept of “strong typing” did seem practical, and with the changes introduced in what would be the first ANSI C standard (a.k.a. C89, which matches K&R2), stronger typing, including the idea of “function prototypes,” was introduced to C as an optional addition. Today nearly 35 years after the first official C standard, most modern compilers now require programmers to use strict type enforcement, and loose typing of the early language seems foreign.

So the answer to your question becomes, since most modern compilers, such as [clang](https://en.wikipedia.org/wiki/Clang "en.wikipedia.org") require formal definitions for all global variables and functions (or, for that matter, globally static to the specific module). Using an external header file for those definitions is more straightforward and, frankly, considered good hygiene. That said, compilers such as [gcc](https://en.wikipedia.org/wiki/GNU_Compiler_Collection "en.wikipedia.org"), may return a warning as opposed to an error if the programmer is sloppy and doesn’t define everything before you try to use it.

As a minor footnote, as the standard has become more strict/compiler implementations moving from warnings to full errors, such as in the case of clang, modern C programming style recommendations have followed the C language programming style found in the 1988 edition K&R2 - a.k.a. “White Book C” - [using function prototypes and explicit typing], which somewhat differs from the original style in K&R1 of 1978.