
• So far in the course, we’ve only had one kind of data structure for representing collections of like values. 
	• structs, recall, give us “containers” for holding variables of different data types, typically. 
	
• Arrays are great for element lookup, but unless we want to insert at the very end of the array, inserting elements is quite costly – remember insertion sort?

• Arrays also suffer from a great inflexibility – what happens if we need a larger array than we thought? 

• Through clever use of pointers, dynamic memory allocation, and structs, we can put those two pieces together to develop a new kind of data structure that gives us the ability to grow and shrink a collection of like values to fit our needs.

• We call this combination of elements, when used in this way, a *linked list*. 

• A linked list *node* is a special kind of struct with two members: 
	• Data of some data type (int, char, float…) 
	• A pointer to another node of the same type 
	
• In this way, a set of nodes together can be thought of as forming a chain of elements that we can follow from beginning to end.

```c
typedef struct sllist 
{ 
	VALUE val; 
	struct sllist* next; 
} sllnode;
```

• In order to work with linked lists effectively, there are a number of operations that we need to understand: 

1. Create a linked list when it doesn’t already exist. 
2. Search through a linked list to find an element. 
3. Insert a new node into the linked list. 
4. Delete a single element from a linked list. 
5. Delete an entire linked list.

• Create a linked list.

```c
sllnode* create(VALUE val);
```

a. Dynamically allocate space for a new sllnode. 
b. Check to make sure we didn’t run out of memory. 
c. Initialize the node’s val field. 
d. Initialize the node’s next field. 
e. Return a pointer to the newly created sllnode.

```c
sllnode* new = create(6);
```

