• A queue is a special type of structure that can be used to maintain data in an organized way. 

• This data structure is commonly implemented in one of two ways: as an *array* or as a *linked list. 

• In either case, the important rule is that when data is added to the queue, it is tacked onto the end, and so if an element needs to be removed, the element at the front is the only element that can legally be removed. 
	• First in, first out (FIFO)
	
• There are only two operations that may legally be performed on a queue. 
	• *Enqueue*: Add a new element to the end of the queue. 
	• *Dequeue*: Remove the oldest element from the front of the queue.

### Array-based implementation

```c
typedef struct _queue 
{
	VALUE array[CAPACITY];
	int front;
	int size;
}
queue;
```

```c 
queue q; 
```

![[Screenshot 2024-08-06 at 12.39.24 PM.png]]

```c 
queue q;
q.front = 0; 
q.size = 0;
```

![[Screenshot 2024-08-06 at 12.40.28 PM.png]]

#### Enqueue: Add a new element to the end of the queue.

In the general case, enqueue() needs to: 
	• Accept a pointer to the queue. 
	• Accept data of type VALUE to be added to the queue. 
	• Add that data to the queue at the end of the queue. 
	• Change the size of the queue.

```c 
void enqueue(queue* q, VALUE data);
```

![[Screenshot 2024-08-06 at 12.42.44 PM.png]]

```c
enqueue(&q, 28);
```

![[Screenshot 2024-08-06 at 12.43.17 PM.png]]
![[Screenshot 2024-08-06 at 12.43.37 PM.png]]

```c
enqueue(&q, 33);
```

![[Screenshot 2024-08-06 at 12.44.33 PM.png]]

```c
enqueue(&q, 19);
```

![[Screenshot 2024-08-06 at 12.45.05 PM.png]]


#### Dequeue: Remove the most recent element from the front of the queue.

In the general case, dequeue() needs to: 
	• Accept a pointer to the queue. 
	• Change the location of the front of the queue. 
	• Decrease the size of the queue. 
	• Return the value that was removed from the queue.


```c
VALUE dequeue(queue* q);
```

```c
int x = dequeue(&q);
```
![[Screenshot 2024-08-06 at 12.47.57 PM.png]]
![[Screenshot 2024-08-06 at 12.48.10 PM.png]]![[Screenshot 2024-08-06 at 12.48.49 PM.png]]

```c
enqueue(&q, 40);
```
![[Screenshot 2024-08-06 at 12.49.45 PM.png]]


### Linked list-based implementation

```c
typedef struct _queue 
{
	VALUE val;
	struct _queue *prev; 
	struct _queue *next;
}
queue;
```

• Just make sure to always maintain pointers to the head and tail of the linked list! (probably global) 

• To enqueue: 
	• Dynamically allocate a new node; 
	• Set its next pointer to NULL, set its prev pointer to the tail; 
	• Set the tail’s next pointer to the new node; 
	• Move the tail pointer to the newly-created node.

![[Screenshot 2024-08-06 at 12.51.40 PM.png]]![[Screenshot 2024-08-06 at 12.51.50 PM.png]]![[Screenshot 2024-08-06 at 12.52.00 PM.png]]![[Screenshot 2024-08-06 at 12.52.09 PM.png]]![[Screenshot 2024-08-06 at 12.52.18 PM.png]]![[Screenshot 2024-08-06 at 12.52.29 PM.png]]

• To dequeue: 
	• Traverse the linked list to its second element (if it exists); 
	• Free the head of the list; 
	• Move the head pointer to the (former) second element; 
	• Make that node’s prev pointer point to NULL.

![[Screenshot 2024-08-06 at 12.57.03 PM.png]]![[Screenshot 2024-08-06 at 12.57.25 PM.png]]![[Screenshot 2024-08-06 at 12.57.36 PM.png]]![[Screenshot 2024-08-06 at 12.57.49 PM.png]]![[Screenshot 2024-08-06 at 12.58.56 PM.png]]![[Screenshot 2024-08-06 at 12.59.05 PM.png]]