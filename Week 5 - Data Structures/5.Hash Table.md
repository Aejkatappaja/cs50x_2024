
• Hash tables combine the random access ability of an array with the dynamism of a linked list. 

• This means (assuming we define our hash table well): 
	• Insertion can start to tend toward q(1) 
	• Deletion can start to tend toward q(1) 
	• Lookup can start to tend toward q(1) 
	
• We’re gaining the advantages of both types of data structure, while mitigating the disadvantages.

• To get this performance upgrade, we create a new structure whereby when we insert data into the structure, the data itself gives us a clue about where we will find the data, should we need to later look it up. 

• The trade off is that hash tables are not great at ordering or sorting data, but if we don’t care about that, then we’re good to go!

• A hash table amounts to a combination of two things with which we’re quite familiar. 
	• First, a hash function, which returns an nonnegative integer value called a hash code. 
	• Second, an array capable of storing data of the type we wish to place into the data structure. 
	
• The idea is that we run our data through the hash function, and then store the data in the element of the array represented by the returned hash code.

![[Screenshot 2024-08-05 at 1.58.27 PM.png]]
![[Screenshot 2024-08-05 at 1.58.49 PM.png]]
![[Screenshot 2024-08-05 at 1.59.10 PM.png]]
![[Screenshot 2024-08-05 at 1.59.21 PM.png]]
![[Screenshot 2024-08-05 at 1.59.50 PM.png]]
![[Screenshot 2024-08-05 at 2.00.27 PM.png]]
![[Screenshot 2024-08-05 at 2.00.40 PM.png]]

• How to define a hash function? Really no limit to the number of possible hash functions. 

• A good hash function should: 
	• Use only the data being hashed 
	• Use all of the data being hashed 
	• Be deterministic 
	• Uniformly distribute data 
	• Generate very different hash codes for very similar data
	
```c
unsigned int hash(char* str) 
{ 
	int sum = 0; 
	for (int j = 0; str[j] != ‘\0’; j++) 
	{ 
		sum += str[j]; 
	} 
	return sum % HASH_MAX; 
}
```

![[Screenshot 2024-08-05 at 2.06.06 PM.png]]![[Screenshot 2024-08-05 at 2.06.13 PM.png]]

• A collision occurs when two pieces of data, when run through the hash function, yield the same hash code. 

• Presumably we want to store both pieces of data in the hash table, so we shouldn’t simply overwrite the data that happened to be placed in there first. 

• We need to find a way to get both elements into the hash table while trying to preserve quick insertion and lookup.

• Resolving collisions: Linear probing 

• In this method, if we have a collision, we try to place the data in the next consecutive element in the array (wrapping around to the beginning if necessary) until we find a vacancy. 

• That way, if we don’t find what we’re looking for in the first location, at least hopefully the element is somewhere nearby.

![[Screenshot 2024-08-05 at 2.06.57 PM.png]]![[Screenshot 2024-08-05 at 2.07.07 PM.png]]![[Screenshot 2024-08-05 at 2.07.17 PM.png]]![[Screenshot 2024-08-05 at 2.07.26 PM.png]]![[Screenshot 2024-08-05 at 2.07.47 PM.png]]![[Screenshot 2024-08-05 at 2.07.55 PM.png]]![[Screenshot 2024-08-05 at 2.08.04 PM.png]]![[Screenshot 2024-08-05 at 2.08.11 PM.png]]![[Screenshot 2024-08-05 at 2.08.20 PM.png]]![[Screenshot 2024-08-05 at 2.08.28 PM.png]]![[Screenshot 2024-08-05 at 2.08.37 PM.png]]![[Screenshot 2024-08-05 at 2.08.45 PM.png]]![[Screenshot 2024-08-05 at 2.08.54 PM.png]]![[Screenshot 2024-08-05 at 2.09.03 PM.png]]![[Screenshot 2024-08-05 at 2.09.10 PM.png]]![[Screenshot 2024-08-05 at 2.09.17 PM.png]]![[Screenshot 2024-08-05 at 2.09.23 PM.png]]![[Screenshot 2024-08-05 at 2.09.32 PM.png]]![[Screenshot 2024-08-05 at 2.09.40 PM.png]]![[Screenshot 2024-08-05 at 2.09.48 PM.png]]

• Resolving collisions: *Linear probing*

• Linear probing is subject to a problem called clustering. Once there’s a miss, two adjacent cells will contain data, making it more likely in the future that the cluster will grow. 

• Even if we switch to another probing technique, we’re still limited. We can only store as much data as we have locations in our array.

• Resolving collisions: *Chaining*

• Let’s start to pull it all together. 

• What if instead of each element of the array holding just one piece of data, it held multiple pieces of data? 

• If each element of the array is a pointer to the head of a linked list, then multiple pieces of data can yield the same hash code and we’ll be able to store it all!

• We’ve eliminated clustering. 

• We know from experience with linked lists that insertion (and creation, if necessary) into a linked list is an O(1) operation. 

• For lookup, we only need to search through what is hopefully a small list, since we’re distributing what would otherwise be one huge list across n lists.

![[Screenshot 2024-08-05 at 2.11.39 PM.png]]
![[Screenshot 2024-08-05 at 2.12.00 PM.png]]![[Screenshot 2024-08-05 at 2.12.08 PM.png]]![[Screenshot 2024-08-05 at 2.12.17 PM.png]]![[Screenshot 2024-08-05 at 2.12.26 PM.png]]![[Screenshot 2024-08-05 at 2.12.35 PM.png]]![[Screenshot 2024-08-05 at 2.12.43 PM.png]]![[Screenshot 2024-08-05 at 2.12.51 PM.png]]![[Screenshot 2024-08-05 at 2.13.00 PM.png]]![[Screenshot 2024-08-05 at 2.13.10 PM.png]]![[Screenshot 2024-08-05 at 2.13.19 PM.png]]![[Screenshot 2024-08-05 at 2.13.30 PM.png]]![[Screenshot 2024-08-05 at 2.13.38 PM.png]]![[Screenshot 2024-08-05 at 2.13.47 PM.png]]![[Screenshot 2024-08-05 at 2.13.55 PM.png]]