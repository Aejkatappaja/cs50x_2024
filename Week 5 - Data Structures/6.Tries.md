
• We have seen a few data structures that handle the mapping of key-value pairs. 
	• Arrays: The key is the element index, the value is the data at that location. 
	• Hash tables: The key is the hash code of the data, the value is a linked list of data hashing to that hash code. 
	
• What about a slightly different kind of data structure where the key is guaranteed to be unique, and the value could be as simple as a Boolean that tells you whether the data exists in the structure?

• Tries combine structures and pointers together to store data in an interesting way. 

• The data to be searched for in the trie is now a roadmap. 
	• If you can follow the map from beginning to end, the data exists in the trie. 
	• If you can’t, it doesn’t. 
	• Unlike with a hash table, there are no collisions, and no two pieces of data (unless they are identical) have the same path.

• Let’s map key-value pairs where the keys are four-digit years (YYYY) and the values are names of universities founded during those years. 

• In a trie, the paths from a central root node to a leaf node (where the school names would be), would be labeled with digits of the year. 

• Each node on the path from root to leaf could have 10 pointers emanating from it, one for each digit.

• To insert an element into the trie, simply build the correct path from the root to the leaf.

```c 
typedef struct_trie 
{
	char university[20];
	struct_trie* paths[10];
}
trie;
```

![[Screenshot 2024-08-06 at 11.15.22 AM.png]]![[Screenshot 2024-08-06 at 11.15.39 AM.png]]![[Screenshot 2024-08-06 at 11.15.50 AM.png]]![[Screenshot 2024-08-06 at 11.16.03 AM.png]]![[Screenshot 2024-08-06 at 11.16.11 AM.png]]![[Screenshot 2024-08-06 at 11.16.21 AM.png]]![[Screenshot 2024-08-06 at 11.16.30 AM.png]]![[Screenshot 2024-08-06 at 11.16.41 AM.png]]![[Screenshot 2024-08-06 at 11.17.02 AM.png]]![[Screenshot 2024-08-06 at 11.17.13 AM.png]]![[Screenshot 2024-08-06 at 11.17.37 AM.png]]![[Screenshot 2024-08-06 at 11.17.48 AM.png]]![[Screenshot 2024-08-06 at 11.18.27 AM.png]]![[Screenshot 2024-08-06 at 11.18.43 AM.png]]![[Screenshot 2024-08-06 at 11.18.53 AM.png]]![[Screenshot 2024-08-06 at 11.19.04 AM.png]]![[Screenshot 2024-08-06 at 11.19.16 AM.png]]![[Screenshot 2024-08-06 at 11.19.27 AM.png]]![[Screenshot 2024-08-06 at 11.19.41 AM.png]]![[Screenshot 2024-08-06 at 11.19.55 AM.png]]![[Screenshot 2024-08-06 at 11.20.04 AM.png]]![[Screenshot 2024-08-06 at 11.20.16 AM.png]]![[Screenshot 2024-08-06 at 11.20.26 AM.png]]![[Screenshot 2024-08-06 at 11.20.41 AM.png]]![[Screenshot 2024-08-06 at 11.20.52 AM.png]]![[Screenshot 2024-08-06 at 11.21.03 AM.png]]![[Screenshot 2024-08-06 at 11.21.25 AM.png]]

• To search for an element in the trie, use successive digits to navigate from the root, and if you can make it to the end without hitting a dead end (a NULL pointer), you’ve found it.

![[Screenshot 2024-08-06 at 11.21.52 AM.png]]![[Screenshot 2024-08-06 at 11.22.02 AM.png]]![[Screenshot 2024-08-06 at 11.22.13 AM.png]]![[Screenshot 2024-08-06 at 11.22.30 AM.png]]![[Screenshot 2024-08-06 at 11.22.40 AM.png]]![[Screenshot 2024-08-06 at 11.22.52 AM.png]]![[Screenshot 2024-08-06 at 11.23.03 AM.png]]![[Screenshot 2024-08-06 at 11.23.13 AM.png]]![[Screenshot 2024-08-06 at 11.23.24 AM.png]]![[Screenshot 2024-08-06 at 11.23.38 AM.png]]![[Screenshot 2024-08-06 at 11.23.49 AM.png]]![[Screenshot 2024-08-06 at 11.24.04 AM.png]]![[Screenshot 2024-08-06 at 11.24.14 AM.png]]![[Screenshot 2024-08-06 at 11.24.25 AM.png]]![[Screenshot 2024-08-06 at 11.24.36 AM.png]]